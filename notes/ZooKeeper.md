# ZooKeeper

## Linearizability

在这之前有必要再来复习一下关于**正确**的定义, 尽管在`6.5840`的新版课程中提前安排了[Linearizability](https://anishathalye.com/testing-distributed-systems-for-linearizability/)这部分的阅读, 不过现在已经有一些遗忘.

```
一个系统的执行历史是一系列的客户端请求,有可能来自一个或多个, 如果我们能找到一个与实际请求相符合的执行顺序, 那么它(请求历史)就是线性一致的.
```

例子中的一个操作:`|-----W(x=1)------|`, 第一个`|`表示客户端发送请求, 第二个`|`表示收到回复, 也就是说对于写操作`x=1`, 在这之间完成.


```
如果我们能构建一个序列, 同时满足条件1和条件2, 那么可以说请求历史是线性的

1 序列中的请求顺序与实际时间匹配
2 每个读请求看到的都是序列中前一个写请求写入的值
```

在按照Morris的方式去进行上面两个条件的判断后, 可以发现如果生成了一个带环的图, 那么请求历史就不是线性一致的.

前面的几个例子都是在上面提到的阅读材料中见过的, 当我们考虑了客户端重发请求的时候, 就有一点不一样了, 考虑这个例子:

```
C1: |----W(x=3)----|    |----W(x=4)----|

C2                    |--R(x)--??

case1:                |--R(x)--|re----------------|
case2:                |--R(x)----=-------|re------|
```

如果因为各种各样的问题导致*C2*发出的读*x*请求丢失, 那么它会重发这个读请求, 这个时候我们不得不考虑*C2*收到的回复应该是多少?

如果是`case1`, 假设这个时候`W(x=4)`还没有执行, 那么这条读请求得到的值应该是3, 如果是`case2`, 重发的时机已经在`W(x=4)`结束, 那么读请求应该返回4;

这个时候我们必须从客户端的角度来定义线性一致性, 如果我们在`case1`标注的返回时间返回*x*

1. group msg
2. shared regs
3. distributed lock