# Chain Replication

## ξ1 Operations and States

- query(objId, opts), 幂等op
- update(objId, newVal, opts), 非幂等op

一个对象拥有一个唯一的标识符*objID*, 定义其拥有的状态:

1. $Hist_{objID}$: 在*tail*服务器中有备份的对象
2. $Pending_{objID}$: 未在*tail*服务器上执行请求的

这些状态的过渡态:

1. **T1**: 客户端请求到达, 加入$Pending$
2. **T2**: 客户端请求被忽略, 从$Pending$中删除
3. **T3**: 客户端请求被执行, 先从$Pending$中删除, 然后执行具体的请求, 视情况修改$Hist_{objID}$

有意思的是, 这里$Pending$的修改指的是加入一个集合, 不知道作者是不是混淆了$Pending_{objID}$, 把它当成一个全局记录的集合, 还是针对某一个对象的集合.

从事件的角度来看, 修改集合$Hist$和$Pending$:

1. 链上的服务器收到来自客户端的请求---修改$Pending$
2. *tail*服务器执行了客户端的请求---修改$Hist$

文章提到, 因此其他的操作, 比如发生在链中间的服务器的事情, 都可以视为是**no-op**, 

## ξ2 Update Propagation Invariant

`后继节点的更新序列一定是其前驱节点更新序列的前缀`

这一性质描述的是某一个时刻, 链上各个节点更新序列的状态, 论文中以$Hist_{S_{i}}$来描述服务器$S_{i}$的更新序列

假设有3个节点和3个请求, 该链的状态变化如下所示:

```
Time1: r3,r2,r1 -> Head -> replica -> tail
                    {}      {}         {}
Time2: r3,r2 -> Head -> replica -> tail
                {r1}      {}         {}
Time3: r3 ->   Head   -> replica -> tail
             {r2, r1}     {r1}       {}
Time4:   Head    ->  replica  -> tail
      {r3,r2,r1}     {r2,r1}      {r1}
....

全部同步:     Head  ->   replica   ->    tail
          {r3,r2,r1}   {r3,r2,r1}     {r3,r2,r1}
```


## ξ3 Server Failures

我们给出解决方案+证明该方案等价于*no-op*或者是*T1,T2,T3*中的一种来说明强一致性仍然保持.

### 1.Failure of the Head

*master*会删除故障的头节点, 这相当于*T2*, 从$Pending$中删除那些头节点接受但尚未转发给下一节点的请求.

```
留意一下, 客户端发给了head节点, 但是head节点故障了导致这些请求从Pending中丢掉, 这符合强一致性吗?
```

### 2.Failure of the Tail

同样的处理方式, 移除掉该服务器, 根据**Update传播不变律**, 靠后的服务器被移除不会造成请求缺失, 因为其前驱服务器总持有更多的请求, 不过更新*tail*后需要重新根据当前的$Hist_{tail}$来修改$Pending$


### 3.Failure of the Mid

如果只是简单的删除挂掉的服务器然后将其前驱和后继连起来会打破**Update传播不变律**

比如:

$S^{-}${$r_{1}$，$r_{2}$，$r_{3}$}----$r_{3}$-->$S${$r_{1}$，$r_{2}$}，------->$S^{+}${$r_{1}$，$r_{2}$}

S挂掉后：

$S^{-}${$r_{1}$，$r_{2}$，$r_{3}$}------->$S^{+}${$r_{1}$，$r_{2}$}

新的请求进来

$S^{-}${$r_{1}$，$r_{2}$，$r_{3}$，$r_{4}$}------->$S^{+}${$r_{1}$，$r_{2}$，$r_{4}$}

此时的$Hist_{S^{+}}$便不再是$Hist_{S^{-}}$的前缀

---

为了更好描述后面的内容, 先来看一个例子, 说明一些符号定义的含义

给定集合`R`和比较规则`<`,

$\bar{r}$={1,2,4}被称为符合$(R, <)$, 当其元素在集合`R`中, 且以规则`<`升序排列,

$\bar{r^{'}}$={3,5,7},

$\bar{r} \oplus \bar{r^{'}}$={1,2,3,4,5,7}, 可以看见$\bar{r}$, $\bar{r^{'}}$, $\bar{r} \oplus \bar{r^{'}}$都符合$(R, <)$

---

解决的办法是让服务器$S_{i}$维护另一个队列$Send_{i}$, 表示其发送给$S_{i}^{+}$的请求消息, 当*tail*([为什么是tail](#Others))应用这些消息后, 会发`ack(r)`通知这些服务器从$Send_{i}$中去除已应用的请求消息, 不难发现: 如果 *i≤j*, 那么 $Hist_{S_{i}} = Hist_{S_{j}} \oplus Send_{i}$. 所以对于一个中间服务器$S$, 从链表中删去其后会进行如下的消息传递:

1. *master*发现$S$崩溃;
2. *master*向$S^{+}$发送消息, 告诉其现在的链表结构变为$S^{-}$--->$S^{+}$;
3. $S^{+}$收到消息后, 发送*ACK*给*master*, 并附带$Hist_{S^{+}}$中最新的一个请求$r_{k}$
4. *master*收到*ACK*消息后, 将*2*,*3*的信息全部告诉$S^{-}$
5. $S^{-}$根据收到的消息, 从$Send_{S^{-}}$中找到$r_{k}$以后的请求内容, 发给$S^{+}$进行同步

## ξ4 Extend Server

往链式集群中添加一个服务器一般说来需要初始化以下状态:

1. $Send_{ext}$
2. $Hist^{ext}$

通常都往队尾添加服务器$S_{tail^{+}}$, 因为这默认$Send_{tail^{+}}$为空, 简化了操作, 而$Hist_{tail} = \oplus Hist_{tail^{+}} + Send_{tail}$, 故将$Hist_{tail}$的所有内容发给$S_{tail^{{+}}}$就完成了初始化,  然后通知客户端该集群变化情况即可.


# Object Storage on CRAQ

## ξ1 CR's problems and CRAQ's improvements

原始的*Chain Replication*由于所有的*query*都通过*tail*服务器进行, 这不利于负债均衡, 其扩展性也很差(不如说添加机器只是增加了容错率并且使*update*性能更差, 对*query*没有丝毫影响), 这些在实践中都是问题.

解决上述热点问题的办法---**apportioned queries**

- *CRAQ*允许链式集群中的每个服务器都可以处理读请求, 同时又保持了强一致性, 这极大提高了读吞吐量, 也均衡了负载, 在处理读多写少的工作负载中, 效果很好.
- *CRAQ*对特殊情况做了处理, 同时也允许应用指定读请求的**最大滞后性**: 
  1. 当发生*write contention*(写竞争)时，为读请求提供最终一致性以保证低延迟
  2. 当发生*transient partitions*(分区故障)时，系统降级为read-only
- 利用上述负载均衡的特性, 设计了一个具有很好的局部性的广域分布式系统
- (undo)提供将一组对象数据的更新打包成原子操作
- (undo)使用多播来优化大型对象数据的更新

可以看到, *CRAQ*提供的服务非常诱人.

## ξ2 Apportioned Queries



# Others

如果我们选择在服务器$S^{+}$执行来自$S$的请求后就从$Send_{S}$中删去, 那么会在某些情况丢失请求内容---**连续若干节点崩溃掉**, 如下情况: 

```
         S1      S2      S3   S4
Hist: {1,2,3,4} {1,2,3}  {1}  {1}
Send: {4}       {2,3}    {}   {}

现在S2和S3挂掉了, 那么请求r2, r3都会丢失
```

## 资料&总结

