# Linearizability Testing

这篇文章的标题叫作**Testing Distributed Systems for Linearizability**, 那么关于本次阅读的内容一个很直观的预测是:

1. 对于一个系统来说, 什么是`Linearizability线性`
2. 如何测试并评判这个属性?

# 正确性

第一个我们需要讨论的是如何定义一个系统的正确性, 以提供`Put(k, v)`与`Get(k)`操作的一个存储系统来说, 我们讨论了**Sequential Specifications**, **Linearizability**

我想主要谈谈后者---Linearizability, 这定义了并行情况下的正确性, 如果一段时间内并行的`Put&Get`操作的结果能够被**线性化**, 那么我们可以称之为正确的, 比如文章中的两个例子.

```
可被线性化的:
client1   Put("x", 0)
client2                 Put("x", 1)
client3                   Get("x")->1
client4                 Get("x")->0


不可线性化的:
client1   Put("x", 0)
client2              Put("x", 1)
client3      Get("x")->1
client4                   Get("x")->0
```

对于后者, 我们无法为client3,4同时正确地**分配线性化点**, 而对于前者我们则可以正确地分配: `1->4->2->3`

现在我们可以回答第一个问题了, 对于一个系统来说, 其是否具有`Linearizability线性`, 是判断该系统是否正确, 可靠的一个指标

# 测试

....

```
一个正确地系统被检测算法误判的例子:

Client A: v=1,Put(x,v)                        check(Get(x))     
            .                                     . 
Client B    .       v=2,Put(x,v)   check(Get(x))  .
            .           .             .           .
            .           .             .           .
time:-------1-----------2-------------3-----------4------->
```

即使在我们看来3,4两次check得到x的值应该都是正确的, 但是由于Client A使用了本地变量`v=1`这一旧数据, 导致检测算法判定该系统不可靠, 所以我们不能继续依赖简单的预测`Get(x)`的值了.

材料中给出了一个改进这个检查的算法:**验证一组执行历史是否满足线性一致性**

详细的解释以及一些算法在这篇文章里可以得到解答, 这里我们暂时不去学习文章中提到的算法.[验证线性一致性算法](https://zhuanlan.zhihu.com/p/41632336)

# Questions

```
With a linearizable key/value storage system,
  could two clients who issue get() requests for
  the same key at the same time receive different values? 

Explain why not, or how it could occur.


对一个线性一致的键值对存储系统来说, 是否会出现两个clents同时调用Get()请求相同的key得到不同的值?
```

线性一致性保持每个`Get()`操作是原子的, 如果有第三个clent也同时调用`Put()`修改该key对应的值, 也就是执行顺序按照`Get->Put->Get`, 那么两次Get得到的值就会不一致, 由于这三个操作都是同时发生的, 该怎么执行应该取决于系统的实现, 所以
这里只是给出一个例子来说明两个同时请求的Get操作得到不一致的值.

# FAQ

从[LEC4 FAQ](https://pdos.csail.mit.edu/6.824/papers/linearizability-faq.txt)中选择感兴趣的问题看就好.
这里都是原文的内容, 仅供笔者后续回头回顾.

1. 什么是线性一致性？
2. 线性一致性检查器是如何工作的？
3. services是否使用线性一致性检查器来实现线性一致性？
4. services是如何实现线性一致性的？
5. 你知道有哪些真实世界的系统使用了Porcupine或类似的测试框架进行测试吗？
6. 还有哪些其他的一致性模型?
7. 为什么线性一致性被称为强一致性模型？
8. 在实践中，人们如何确保他们的分布式系统是正确的？
9. 为什么选择线性一致性作为一致性模型，而不是其他的，比如最终一致性？
10. 你是如何决定线性一致性的小橙线（操作的线性化点）应该在哪里？在图上看起来，它似乎是随机画在请求的主体内的某个地方？
11. 是否有这样的情况，即如果两个命令同时执行，我们能够强制执行特定的行为，使得一个命令总是先执行（即它总是有一个更早的线性化点）？
12. 我们可以执行哪些更强的一致性检查？从某种程度上说，线性一致性并不直观地感觉很有帮助，因为即使你同时执行两个命令，你也可能读到不同的数据。
13. 是什么使得验证真实系统需要"巨大的努力"？
14. 从指定的阅读材料中，大多数分布式系统并没有被正式证明是正确的。那么，一个团队如何决定一个框架或系统已经被测试得足够好，可以作为真实产品发布？
15. 为什么不使用客户端发送命令的时间作为线性化点？也就是说，让系统按照客户端发送它们的顺序来执行操作？
16. 如果有并发的put()，那么并发的get()可能看到不同的值，这是个问题吗？

笔者感兴趣的问题`6,7,9,11,12,14,15,16`下面是对应的解释:

***answer of 6th***

1. 最终一致性
2. 因果一致性
3. 分叉一致性
4. 可串行化
5. 顺序一致性
6. 时间线一致性

```
还有其他一些来自数据库、CPU内存/缓存系统和文件系统世界的一致性模型。

总的来说，不同的模型在对应用程序员的直观性以及你可以从中获得的性能上有所不同。例如，最终一致性允许许多异常结果（例如，即使写操作已经完成，后续的读操作可能看不到它），但在分布式/复制的设置中，可以比线性一致性实现更高的性能。
```

***answer of 7th***

```
它之所以被称为强一致性，是因为它禁止了许多可能让应用程序员感到惊讶的情况。

例如，如果我调用put(x, 22)，并且我的put操作完成了，没有其他人写x，然后你调用get(x)，你保证看到的值不会是除22以外的其他值。也就是说，读操作看到的是最新的数据。

再举一个例子，如果没有人在写x，我调用get(x)，你调用get(x)，我们不会看到不同的值。

这些属性在我们将要看到的一些其他一致性模型中并不成立，例如最终一致性和因果一致性。这些后者的模型通常被称为"弱"一致性。
```

***answer of 9th***

```
人们确实经常构建提供比线性一致性弱的一致性的存储系统，如最终一致性和因果一致性。

线性一致性对于应用程序编写者有一些好的属性：

* 读操作总是观察到最新的数据。
* 如果没有并发写操作，所有的读者看到的都是相同的数据。
* 在大多数线性一致性系统上，你可以添加像测试和设置这样的小型事务（因为大多数线性一致性设计最终都会一次执行每个数据项上的操作）。

像最终一致性和因果一致性这样的弱一致性方案可以允许更高的性能，因为它们不需要立即更新所有的数据副本。这种更高的性能通常是决定性的因素。然而，弱一致性为应用程序编写者引入了一些复杂性：

* 读操作可以观察到过时的（陈旧的）数据。
* 读操作可以观察到乱序的写操作。
* 如果你写入，然后读取，你可能看不到你的写入，而是看到陈旧的数据。
* 对同一项的并发更新不是一次执行一个，所以很难实现像测试和设置这样的小型事务。
```


***answer of 11th***

```
在一个线性一致性的存储服务中（例如GFS，或者你的Lab 3），如果来自多个客户端的请求大约在同一时间到达，服务可以选择它执行它们的顺序。虽然在实践中，大多数服务按照请求数据包在网络上到达的顺序执行并发请求。

线性化点的概念是检查一个历史是否线性一致的策略之一的一部分。实际的实现通常不涉及显式的线性化点的概念。相反，它们通常只是按照某种串行（一次一个）的顺序执行传入的请求。你可以将每个操作的线性化点视为在服务执行请求的时间期间的某个地方。
```

***answer of 12th***

```
的确，线性一致性让人想起在程序中使用线程而不使用锁 -- 对同一数据的任何并发访问都是竞争条件。这种方式可以正确地编程，但需要小心。

下一个最强的一致性概念涉及到许多数据库中找到的事务，这些事务有效地锁定了任何使用的数据。对于读写多个数据项的程序，事务使编程比线性一致性更容易。"可串行化"是提供事务的一种一致性模型的名称。

然而，事务系统比线性一致性系统更复杂，更慢，更难以容错。
```

***answer of 14th***

```
在你的公司耗尽资金并破产之前开始销售产品并获得收入是个好主意。人们会在那个点之前尽可能多地进行测试，通常会试图说服一些早期的客户使用产品（并帮助揭示bug），理解它可能无法正确工作。也许当产品功能足够满足许多客户并且没有已知的重大bug时，你就准备好发货了。

独立于此，一个明智的客户也会测试他们依赖的软件。没有任何严肃的组织期望任何软件是无bug的。
```

***answer of 15th***

```
构建一个能保证这种行为的系统是很困难的 -- 开始时间是客户端代码发出请求的时间，但是由于网络延迟，服务可能要到很久以后才收到请求。也就是说，请求可能按照与开始时间的顺序完全不同的顺序到达服务。服务原则上可以延迟执行每个到达的请求，以防一个发出时间更早的请求后来到达，但是由于网络不保证边界延迟，所以很难做到这一点。并且它会增加每个请求的延迟，可能会增加很多。话虽如此，我们稍后将看到的Spanner使用了一种相关的技术。

像线性一致性这样的正确性规范需要在足够宽松以便有效实现，但又足够严格以向应用程序提供有用的保证之间找到一个平衡。"看起来按照调用顺序执行操作"对于有效实现来说太严格了，而线性一致性的"看起来在调用和响应之间的某个地方执行"虽然可以实现，但对于应用程序员来说并不直观。
```

***answer of 16th***

```
在存储系统的上下文中，这通常不是问题。例如，如果我们谈论的值是我的个人资料照片，而两个不同的人在我更新照片的同时请求查看它，那么他们看到不同的照片（旧的或新的）是非常合理的。

一些存储系统提供了更复杂的方案，特别是事务，使这更容易。事务自动锁定数据以防止并发读/写。"可串行化"是提供事务的一种一致性模型的名称。然而，事务系统比线性一致性系统更复杂，更慢，更难以容错。
```
